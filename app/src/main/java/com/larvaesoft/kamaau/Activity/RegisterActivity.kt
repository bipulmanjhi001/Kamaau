package com.larvaesoft.kamaau.Activity

import android.annotation.SuppressLint
import android.app.Activity
import android.app.AlertDialog
import android.app.DatePickerDialog
import android.app.Dialog
import android.content.DialogInterface
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.location.Location
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.support.v7.app.AppCompatActivity
import android.text.TextUtils
import android.util.Log

import com.bumptech.glide.Glide
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.DatabaseReference
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ValueEventListener

import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileNotFoundException
import java.io.FileOutputStream
import java.io.IOException

import de.hdodenhof.circleimageview.CircleImageView
import larvaesoft.com.kamaau.R

import com.larvaesoft.kamaau.model.RegisterPOJO
import com.larvaesoft.kamaau.model.Utility


import android.Manifest
import android.content.Context
import android.location.Address
import android.location.Geocoder
import android.location.LocationListener
import android.location.LocationManager
import android.net.Uri
import android.os.Build
import android.provider.Settings
import android.support.v4.app.ActivityCompat
import android.support.v4.content.ContextCompat


import android.Manifest.permission.ACCESS_COARSE_LOCATION
import android.Manifest.permission.ACCESS_FINE_LOCATION
import android.view.*
import android.widget.*
import com.larvaesoft.kamaau.passwordgenerator.RandomPasswordGenerator
import com.larvaesoft.kamaau.ui.dashboard.Home
import java.util.*

class RegisterActivity : AppCompatActivity() {

    lateinit var gid: String
    lateinit var getphoto: String
    lateinit var email: String
    lateinit var name: String
    lateinit var your_ref_code: String
    lateinit var name_field: EditText
    lateinit var dob: EditText
    lateinit var email_field: TextView
    lateinit var country:EditText
    lateinit var phone: EditText
    lateinit var gender: EditText
    lateinit var city: EditText
    lateinit var pincode: EditText
    lateinit var state: EditText
    lateinit var reffral_code: EditText
    lateinit var your_referral_code:EditText

    lateinit var get_name: String
    lateinit var get_country_name:String
    lateinit var get_email: String
    lateinit var get_dob: String
    lateinit var get_phone: String
    lateinit var get_gender: String
    lateinit var get_city: String
    lateinit var get_pincode: String
    lateinit var get_state: String
    lateinit var get_reffral_code: String
    lateinit var profile_image: CircleImageView
    lateinit var select_image: ImageView
    lateinit var create_account: LinearLayout

    private val REQUEST_CAMERA = 0
    private val SELECT_FILE = 1
    private var userChoosenTask: String? = null

    private var mFirebaseDatabase: DatabaseReference? = null
    private var mFirebaseInstance: FirebaseDatabase? = null

    private var userId: String? = null
    internal var mcalendar = Calendar.getInstance()
    internal var day: Int = 0
    internal var month: Int = 0
    internal var year: Int = 0
    lateinit var genders: String
    lateinit var pref: SharedPreferences
    private var gps_enabled = false
    private var network_enabled = false
    internal var location: Location? = null
    internal var MyLat: Double? = null
    internal var MyLong: Double? = null
    internal var CityName = ""
    internal var StateName = ""
    internal var PostalCode = ""
    internal var CountryName = ""
    internal var SubAdminName = ""


    val noOfCAPSAlpha = 4
    val noOfDigits =2
    val noOfSplChars = 1
    val minLen = 8
    val maxLen = 8
    val noOfCAPSAlpha2 = 1
    lateinit var your_password: String

    // Generate a reference to a new location and add some data using push()
    var pushedPostRef = mFirebaseDatabase?.push()
    // Get the unique ID generated by a push()
    var postId = pushedPostRef?.getKey()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_register)

        gid = intent.getStringExtra("gid")
        getphoto = intent.getStringExtra("getphoto")
        email = intent.getStringExtra("email")
        name = intent.getStringExtra("name")

        GetFields()

        mFirebaseInstance = FirebaseDatabase.getInstance()
        // get reference to 'users' node
        mFirebaseDatabase = mFirebaseInstance!!.getReference("users")

        mFirebaseInstance!!.getReference("app_title").setValue("Kamaau Database")

        // app_title change listener
        mFirebaseInstance!!.getReference("app_title").addValueEventListener(object : ValueEventListener {
            override fun onDataChange(dataSnapshot: DataSnapshot) {
                Log.e(TAG, "App title updated")
            }

            override fun onCancelled(error: DatabaseError) {
                // Failed to read value
                Log.e(TAG, "Failed to read app title value.", error.toException())
            }
        })

    }

    fun GetFields() {


        day = mcalendar.get(Calendar.DAY_OF_MONTH)
        year = mcalendar.get(Calendar.YEAR)
        month = mcalendar.get(Calendar.MONTH) + 1
        profile_image = findViewById<View>(R.id.profile_image) as CircleImageView

        try {
            if (!getphoto.isEmpty()) {
                Glide.with(applicationContext)
                        .load(getphoto)
                        .thumbnail(0.5f)
                        .into(profile_image)
            }
        } catch (e: NullPointerException) {
            e.printStackTrace()
        }

        select_image = findViewById<View>(R.id.select_image) as ImageView
        select_image.setOnClickListener { selectImage() }

        name_field = findViewById<View>(R.id.name) as EditText
        name_field.setText(name)
        dob = findViewById<View>(R.id.dob) as EditText
        dob.setOnClickListener { DateDialog() }

        email_field = findViewById<View>(R.id.email) as TextView
        email_field.setText(email)
        phone = findViewById<View>(R.id.phone) as EditText
        gender = findViewById<View>(R.id.gender) as EditText
        gender.setOnClickListener { showCustomDialog() }

        city = findViewById<View>(R.id.city) as EditText
        pincode = findViewById<View>(R.id.pincode) as EditText
        country = findViewById<View>(R.id.country) as EditText
        state = findViewById<View>(R.id.state) as EditText
        reffral_code = findViewById<View>(R.id.referral_code) as EditText

        your_referral_code=findViewById<View>(R.id.your_referral_code) as EditText
        if (!checkPermission()) {
            requestPermission()
        } else if (checkPermission()) {
            getAddress()
        }
        create_account = findViewById<View>(R.id.register_proceed) as LinearLayout
        create_account.setOnClickListener { validateData() }

        for (i in 0..9) {
            val pswd = RandomPasswordGenerator.generatePswd(minLen, maxLen,
                    noOfDigits, noOfCAPSAlpha, noOfSplChars, noOfCAPSAlpha2)

            your_referral_code.setText(String(pswd))
            your_password=String(pswd)
        }
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
        when (requestCode) {
            Utility.MY_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE -> if (grantResults.size > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                if (userChoosenTask == "Take Photo")
                    cameraIntent()
                else if (userChoosenTask == "Choose from Gallery")
                    galleryIntent()
            } else {
                //code for deny
            }

            MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION -> {
                if (grantResults.size > 0) {
                    val locationAccepted = grantResults[0] == PackageManager.PERMISSION_GRANTED

                    if (locationAccepted) {
                    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                        if (shouldShowRequestPermissionRationale(ACCESS_FINE_LOCATION)) {
                            showMessageOKCancel("You need to allow access to both the permissions",
                                    DialogInterface.OnClickListener { dialog, which ->
                                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                                            requestPermissions(arrayOf(ACCESS_FINE_LOCATION),
                                                    MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION)
                                        }
                                    })
                            return
                        }
                    }

                }
                if (grantResults.size > 0) {
                    val locationAccepted = grantResults[0] == PackageManager.PERMISSION_GRANTED

                    if (locationAccepted) {
                        getAddress()
                    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                        if (shouldShowRequestPermissionRationale(ACCESS_COARSE_LOCATION)) {
                            showMessageOKCancel("You need to allow access to both the permissions",
                                    DialogInterface.OnClickListener { dialog, which ->
                                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                                            requestPermissions(arrayOf(ACCESS_COARSE_LOCATION),
                                                    MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION)
                                        }
                                    })
                            return
                        }
                    }

                }
            }
            MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION -> if (grantResults.size > 0) {
                val locationAccepted = grantResults[0] == PackageManager.PERMISSION_GRANTED
                if (locationAccepted) {
                    getAddress()
                } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    if (shouldShowRequestPermissionRationale(ACCESS_COARSE_LOCATION)) {
                        showMessageOKCancel("You need to allow access to both the permissions", DialogInterface.OnClickListener { dialog, which ->
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                                requestPermissions(arrayOf(ACCESS_COARSE_LOCATION), MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION)
                            }
                        })
                        return
                    }
                }
            }
        }
    }

    private fun selectImage() {
        val items = arrayOf<CharSequence>("Take Photo", "Choose from Gallery", "Cancel")
        val builder = AlertDialog.Builder(this@RegisterActivity)
        builder.setTitle("Add Photo!")
        builder.setItems(items) { dialog, item ->
            if (items[item] == "Take Photo") {
                userChoosenTask = "Take Photo"
                val result = Utility.checkPermission(this@RegisterActivity)
                if (result)
                    cameraIntent()

            } else if (items[item] == "Choose from Gallery") {
                userChoosenTask = "Choose from Gallery"
                val result = Utility.checkPermission(this@RegisterActivity)
                if (result)
                    galleryIntent()

            } else if (items[item] == "Cancel") {
                dialog.dismiss()
            }
        }
        builder.show()
    }

    private fun galleryIntent() {
        val intent = Intent()
        intent.type = "image/*"
        intent.action = Intent.ACTION_GET_CONTENT
        startActivityForResult(Intent.createChooser(intent, "Select File"), SELECT_FILE)
    }

    private fun cameraIntent() {
        val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
        startActivityForResult(intent, REQUEST_CAMERA)
    }

    public override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
        super.onActivityResult(requestCode, resultCode, data)

        if (resultCode == Activity.RESULT_OK) {
            if (requestCode == SELECT_FILE)
                onSelectFromGalleryResult(data)
            else if (requestCode == REQUEST_CAMERA)
                onCaptureImageResult(data)
        }
    }

    private fun onCaptureImageResult(data: Intent) {
        val thumbnail = data.extras!!.get("data") as Bitmap
        val bytes = ByteArrayOutputStream()
        thumbnail.compress(Bitmap.CompressFormat.JPEG, 90, bytes)

        val destination = File(Environment.getExternalStorageDirectory(),
                System.currentTimeMillis().toString() + ".jpg")
        val fo: FileOutputStream
        try {
            destination.createNewFile()
            fo = FileOutputStream(destination)
            fo.write(bytes.toByteArray())
            fo.close()
        } catch (e: FileNotFoundException) {
            e.printStackTrace()
        } catch (e: IOException) {
            e.printStackTrace()
        }

        profile_image.setImageBitmap(thumbnail)
        val savedestination = destination.absolutePath
        Log.d("savedestination", savedestination)
        profile_image.visibility = View.VISIBLE
    }

    private fun onSelectFromGalleryResult(data: Intent?) {

        var bm: Bitmap? = null
        if (data != null) {
            try {
                bm = MediaStore.Images.Media.getBitmap(applicationContext.contentResolver, data.data)
            } catch (e: IOException) {
                e.printStackTrace()
            }

        }
        profile_image.setImageBitmap(bm)
        profile_image.visibility = View.VISIBLE
    }

    override fun onBackPressed() {
        this@RegisterActivity.finish()
    }

    //Validate Data locally(Checks whether the fields are empty or not)
    private fun validateData() {
        var cancel = false
        var focusView: View? = null
        if (TextUtils.isEmpty(name_field.text.toString())) {
            name_field.error = "Required field!"
            focusView = name_field
            cancel = true
        } else if (TextUtils.isEmpty(dob.text.toString())) {
            dob.error = "Required field!"
            focusView = dob
            cancel = true
        } else if (TextUtils.isEmpty(email_field.text.toString())) {
            email_field.error = "Required field!"
            focusView = email_field
            cancel = true
        } else if (TextUtils.isEmpty(phone.text.toString())) {
            phone.error = "Required field!"
            focusView = phone
            cancel = true
        } else if (TextUtils.isEmpty(gender.text.toString())) {
            gender.error = "Required field!"
            focusView = gender
            cancel = true
        } else if (TextUtils.isEmpty(city.text.toString())) {
            city.error = "Required field!"
            focusView = city
            cancel = true
        } else if (TextUtils.isEmpty(pincode.text.toString())) {
            pincode.error = "Required field!"
            focusView = pincode
            cancel = true
        } else if (TextUtils.isEmpty(state.text.toString())) {
            state.error = "Required field!"
            focusView = state
            cancel = true
        }else if (TextUtils.isEmpty(country.text.toString())) {
            country.error = "Required field!"
            focusView = country
            cancel = true
        } else if (TextUtils.isEmpty(reffral_code.text.toString())) {
            reffral_code.error = "Required field!"
            focusView = reffral_code
            cancel = true
        }else if (TextUtils.isEmpty(your_referral_code.text.toString())) {
            your_referral_code.error = "Required field!"
            focusView = your_referral_code
            cancel = true
        }
        if (cancel) {
            focusView!!.requestFocus()
        } else {
            getTextValues()
        }
    }
    //Get the values from EditText
    private fun getTextValues() {
        create_account.setOnClickListener {
            get_name = name_field.text.toString()
            get_email = email_field.text.toString()
            get_city = city.text.toString()

            get_dob = dob.text.toString()
            get_phone = phone.text.toString()
            get_pincode = pincode.text.toString()
            get_reffral_code = reffral_code.text.toString()

            get_state = state.text.toString()
            get_gender = gender.text.toString()
            get_country_name=country.text.toString()
            your_ref_code=your_referral_code.text.toString()

            try {
               // if (get_reffral_code == "LSOFT/KAM") {
                    if (TextUtils.isEmpty(userId)) {
                        createUser(get_name, get_email, get_phone, get_dob, get_gender, get_city, get_pincode, get_state, get_country_name, get_reffral_code, your_ref_code)

                        Toast.makeText(this@RegisterActivity, "Registration succeed.", Toast.LENGTH_LONG).show()

                        pref = applicationContext.getSharedPreferences("register_save", Context.MODE_PRIVATE)
                        val logineditor: SharedPreferences.Editor
                        logineditor = pref.edit()
                        logineditor.putString("email", email)
                        logineditor.putString("gid", gid)
                        logineditor.putString("name", name)
                        logineditor.putString("uuid",userId)
                        logineditor.putString("getphoto", getphoto)
                        logineditor.putString("your_pass",your_password)
                        logineditor.putString("phone",get_phone)
                        logineditor.putString("your_ref_code",your_ref_code)
                        logineditor.apply()

                        val intent = Intent(this@RegisterActivity, Home::class.java)
                        startActivity(intent)
                        finish()

                    } else {
                        updateUser(get_name, get_email, get_phone, get_dob, get_gender, get_city, get_pincode, get_state, get_country_name, get_reffral_code, your_ref_code)

                        Toast.makeText(this@RegisterActivity, "Registration Updated succeed.", Toast.LENGTH_LONG).show()

                        pref = applicationContext.getSharedPreferences("register_save", Context.MODE_PRIVATE)
                        val logineditor: SharedPreferences.Editor
                        logineditor = pref.edit()
                        logineditor.putString("email", email)
                        logineditor.putString("gid", gid)
                        logineditor.putString("name", name)
                        logineditor.putString("uuid",userId)
                        logineditor.putString("getphoto", getphoto)
                        logineditor.putString("your_pass",your_password)
                        logineditor.putString("phone",get_phone)
                        logineditor.putString("your_ref_code",your_ref_code)
                        logineditor.apply()

                        val intent = Intent(this@RegisterActivity, Home::class.java)
                        startActivity(intent)
                        finish()
                    }

               /* } else {

                    Toast.makeText(applicationContext, "Check your Referral Code", Toast.LENGTH_SHORT).show()
                }*/

            } catch (e: IllegalArgumentException) {
                e.printStackTrace()
            }
        }

    }

    /**
     * Creating new user node under 'users'
     */
    private fun createUser(name: String, email: String, phone: String, dob: String, gender: String, city: String, pincode: String, state: String, country_name: String, refrral_code: String, ref_code: String) {
        // TODO
        // In real apps this userId should be fetched
        // by implementing firebase auth
        if (TextUtils.isEmpty(userId)) {
            userId = mFirebaseDatabase!!.push().key
        }

        val registerPOJO = RegisterPOJO(name, email, phone, dob, gender, city, pincode, state, country_name, refrral_code, ref_code)
        mFirebaseDatabase!!.child(userId!!).setValue(registerPOJO)
        addUserChangeListener()
    }
    /**
     * User data change listener
     */
    private fun addUserChangeListener() {
        // User data change listener
        mFirebaseDatabase!!.child(userId!!).addValueEventListener(object : ValueEventListener {
            override fun onDataChange(dataSnapshot: DataSnapshot) {
                val registerPOJO = dataSnapshot.getValue(RegisterPOJO::class.java)

                // Check for null
                if (registerPOJO == null) {
                    Log.e(TAG, "RegisterPOJO data is null!")
                    return
                }
            }

            override fun onCancelled(error: DatabaseError) {
                // Failed to read value
                Log.e(TAG, "Failed to Register", error.toException())
            }
        })
    }

    private fun updateUser(name: String, email: String, phone: String, dob: String, gender: String, city: String, pincode: String, state: String, country_name: String, refrral_code:String, ref_code: String) {
        // updating the user via child nodes
        if (!TextUtils.isEmpty(name))
            mFirebaseDatabase!!.child(userId!!).child("name").setValue(name)

        if (!TextUtils.isEmpty(email))
            mFirebaseDatabase!!.child(userId!!).child("email").setValue(email)

        if (!TextUtils.isEmpty(phone))
            mFirebaseDatabase!!.child(userId!!).child("phone").setValue(phone)

        if (!TextUtils.isEmpty(dob))
            mFirebaseDatabase!!.child(userId!!).child("dob").setValue(dob)

        if (!TextUtils.isEmpty(gender))
            mFirebaseDatabase!!.child(userId!!).child("gender").setValue(gender)

        if (!TextUtils.isEmpty(city))
            mFirebaseDatabase!!.child(userId!!).child("city").setValue(city)

        if (!TextUtils.isEmpty(pincode))
            mFirebaseDatabase!!.child(userId!!).child("pincode").setValue(pincode)

        if (!TextUtils.isEmpty(state))
            mFirebaseDatabase!!.child(userId!!).child("state").setValue(state)

        if (!TextUtils.isEmpty(country_name))
            mFirebaseDatabase!!.child(userId!!).child("country").setValue(country_name)

        if (!TextUtils.isEmpty(ref_code))
            mFirebaseDatabase!!.child(userId!!).child("referral_code").setValue(ref_code)

        if (!TextUtils.isEmpty(ref_code))
            mFirebaseDatabase!!.child(userId!!).child("code").setValue(ref_code)

    }

    fun DateDialog() {
        val listener = DatePickerDialog.OnDateSetListener { view, year, monthOfYear, dayOfMonth -> dob.setText(dayOfMonth.toString() + "/" + monthOfYear + "/" + year) }
        val dpDialog = DatePickerDialog(this, listener, year, month, day)
        dpDialog.show()
    }

    private fun showCustomDialog() {
        val customDialog = Dialog(this@RegisterActivity)

        customDialog.setContentView(R.layout.custom_dailog_layout)
        val genderRadioGroup: RadioGroup
        val maleRadioButton: RadioButton
        val femaleRadioButton: RadioButton
        val btnOk: Button
        genders = ""
        val window = customDialog.window
        window!!.setLayout(WindowManager.LayoutParams.MATCH_PARENT,
                WindowManager.LayoutParams.WRAP_CONTENT)
        window.setGravity(Gravity.CENTER)

        btnOk = customDialog.findViewById<View>(R.id.btnOk) as Button
        genderRadioGroup = customDialog.findViewById<View>(R.id.genderRadioGroup) as RadioGroup
        maleRadioButton = customDialog.findViewById<View>(R.id.maleRadioButton) as RadioButton
        femaleRadioButton = customDialog.findViewById<View>(R.id.femaleRadioButton) as RadioButton

        genderRadioGroup.setOnCheckedChangeListener { radioGroup, checkedId ->
            if (checkedId == R.id.maleRadioButton) {
                genders = "Male"
            } else if (checkedId == R.id.femaleRadioButton) {
                genders = "Female"
            }
        }
        btnOk.setOnClickListener {
            if (!genders.isEmpty()) {
                gender.setText(genders)
                customDialog.dismiss()
            } else {
                Toast.makeText(this@RegisterActivity, "Please Select Gender", Toast.LENGTH_SHORT).show()
            }
        }
        customDialog.show()
    }

    private fun checkPermission(): Boolean {
        val result = ContextCompat.checkSelfPermission(applicationContext, ACCESS_FINE_LOCATION)
        val result2 = ContextCompat.checkSelfPermission(applicationContext, ACCESS_COARSE_LOCATION)
        return result == PackageManager.PERMISSION_GRANTED && result2 == PackageManager.PERMISSION_GRANTED
    }

    private fun requestPermission() {
        ActivityCompat.requestPermissions(this, arrayOf(ACCESS_FINE_LOCATION), MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION)
        ActivityCompat.requestPermissions(this, arrayOf(ACCESS_COARSE_LOCATION), MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION)
    }

    private fun showMessageOKCancel(message: String, okListener: DialogInterface.OnClickListener) {
        AlertDialog.Builder(this@RegisterActivity)
                .setMessage(message)
                .setPositiveButton("OK", okListener)
                .setNegativeButton("Cancel", null)
                .create()
                .show()
    }

    fun getAddress() {
        // TODO Auto-generated method stub

        turnGPSOn() // method to turn on the GPS if its in off state.
        getMyCurrentLocation()
    }

    /** Method to turn on GPS  */

    fun turnGPSOn() {
        try {
            val provider = Settings.Secure.getString(contentResolver, Settings.Secure.LOCATION_PROVIDERS_ALLOWED)

            if (!provider.contains("gps")) { //if gps is disabled
                val poke = Intent()
                poke.setClassName("com.android.settings", "com.android.settings.widget.SettingsAppWidgetProvider")
                poke.addCategory(Intent.CATEGORY_ALTERNATIVE)
                poke.data = Uri.parse("3")
                sendBroadcast(poke)
            }
        } catch (e: Exception) {

        }

    }

    // Method to turn off the GPS
    fun turnGPSOff() {
        val provider = Settings.Secure.getString(contentResolver, Settings.Secure.LOCATION_PROVIDERS_ALLOWED)
        if (provider.contains("gps")) { //if gps is enabled

            val poke = Intent()
            poke.setClassName("com.android.settings", "com.android.settings.widget.SettingsAppWidgetProvider")
            poke.addCategory(Intent.CATEGORY_ALTERNATIVE)
            poke.data = Uri.parse("3")
            sendBroadcast(poke)
        }
    }

    // turning off the GPS if its in on state. to avoid the battery drain.
    override fun onDestroy() {
        // TODO Auto-generated method stub
        super.onDestroy()
        turnGPSOff()
    }


    /** Check the type of GPS Provider available at that instance and  collect the location informations
     * @Output Latitude and Longitude
     */
    internal fun getMyCurrentLocation() {

        val locManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager
        val locListener = MyLocationListener()
        try {
            gps_enabled = locManager.isProviderEnabled(LocationManager.GPS_PROVIDER)
        } catch (ex: Exception) {
        }

        try {
            network_enabled = locManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)
        } catch (ex: Exception) {
        }

        //don't start listeners if no provider is enabled

        //if(!gps_enabled && !network_enabled)

        //return false;

        if (gps_enabled) {
            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                // TODO: Consider calling
                //    ActivityCompat#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for ActivityCompat#requestPermissions for more details.
                return
            }
            locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0f, locListener)

        }


        if (gps_enabled) {
            location = locManager.getLastKnownLocation(LocationManager.GPS_PROVIDER)

        }

        if (network_enabled && location == null) {

            locManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0f, locListener)

        }
        if (network_enabled && location == null) {
            location = locManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)

        }

        if (location != null) {

            MyLat = location!!.latitude
            MyLong = location!!.longitude
        } else {
            val loc = getLastKnownLocation(this)
            if (loc != null) {
                MyLat = loc.latitude
                MyLong = loc.longitude
            }
        }

        locManager.removeUpdates(locListener) // removes the periodic updates from location listener to avoid battery drainage. If you want to get location at the periodic intervals call this method using pending intent.

        try {
            // Getting address from found locations.
            val geocoder: Geocoder
            val addresses: List<Address>
            geocoder = Geocoder(this, Locale.getDefault())
            addresses = geocoder.getFromLocation(MyLat!!, MyLong!!, 1)

            StateName = addresses[0].adminArea
            CityName = addresses[0].locality
            PostalCode = addresses[0].postalCode
            CountryName = addresses[0].countryName
            SubAdminName = addresses[0].getAddressLine(0)

        } catch (e: Exception) {
            e.printStackTrace()
        }

        try {
            if (CityName == "") {
                city.setText("")
            } else if (CityName != "") {
                city.setText(CityName)
            }
            if (PostalCode == "") {
                pincode.setText("")
            } else if (PostalCode != "") {
                pincode.setText(PostalCode)

            }
            if (StateName == "") {
                state.setText("")
            } else if (StateName != "") {
                state.setText(StateName)
            }
            if (CountryName == "") {
                country.setText("")
            } else if (CountryName  != "") {
                country.setText(CountryName )
            }

        } catch (e: NullPointerException) {
            e.printStackTrace()
        }

    }

    // Location listener class. to get location.
    inner class MyLocationListener : LocationListener {
        override fun onLocationChanged(location: Location?) {
            if (location != null) {
            }
        }

        override fun onProviderDisabled(provider: String) {
            // TODO Auto-generated method stub
        }

        override fun onProviderEnabled(provider: String) {
            // TODO Auto-generated method stub
        }

        override fun onStatusChanged(provider: String, status: Int, extras: Bundle) {
            // TODO Auto-generated method stub
        }
    }

    companion object {

        val MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION = 124
        val MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION = 125
        private val TAG = RegisterActivity::class.java.simpleName

        // below method to get the last remembered location. because we don't get locations all the times .At some instances we are unable to get the location from GPS. so at that moment it will show us the last stored location.

        @SuppressLint("WrongConstant")
        fun getLastKnownLocation(context: Context): Location? {
            var location: Location? = null
            @SuppressLint("WrongConstant")
            val locationmanager = context.getSystemService("location") as LocationManager
            val list = locationmanager.allProviders
            var i = false
            val iterator = list.iterator()
            do {
                //System.out.println("---------------------------------------------------------------------");
                if (!iterator.hasNext())
                    break
                val s = iterator.next() as String
                //if(i != 0 && !locationmanager.isProviderEnabled(s))
                if (i != false && !locationmanager.isProviderEnabled(s))
                    continue
                // System.out.println("provider ===> "+s);
                if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                    // TODO: Consider calling
                    //    ActivityCompat#requestPermissions
                    // here to request the missing permissions, and then overriding
                    //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                    //                                          int[] grantResults)
                    // to handle the case where the user grants the permission. See the documentation
                    // for ActivityCompat#requestPermissions for more details.

                }
                val location1 = locationmanager.getLastKnownLocation(s) ?: continue
                if (location != null) {
                    //System.out.println("location ===> "+location);
                    //System.out.println("location1 ===> "+location);
                    val f = location.accuracy
                    val f1 = location1.accuracy
                    if (f >= f1) {
                        val l = location1.time
                        val l1 = location.time
                        if (l - l1 <= 600000L)
                            continue
                    }
                }
                location = location1
                // System.out.println("location  out ===> "+location);
                //System.out.println("location1 out===> "+location);
                i = locationmanager.isProviderEnabled(s)

            } while (true)
            return location
        }
    }


    private fun uploadFile() {

        /* //checking if file is available
        if (filePath != null) {
            //displaying progress dialog while image is uploading
            final ProgressDialog progressDialog = new ProgressDialog(this);
            progressDialog.setTitle("Uploading");
            progressDialog.show();

            //getting the storage reference
            StorageReference sRef = storageReference.child(Constants.STORAGE_PATH_UPLOADS + System.currentTimeMillis() + "." + getFileExtension(filePath));

            //adding the file to reference
            sRef.putFile(filePath)
                    .addOnSuccessListener(new OnSuccessListener<UploadTask.TaskSnapshot>() {
                        @Override
                        public void onSuccess(UploadTask.TaskSnapshot taskSnapshot) {
                            //dismissing the progress dialog
                            progressDialog.dismiss();

                            //displaying success toast
                            Toast.makeText(getApplicationContext(), "File Uploaded ", Toast.LENGTH_LONG).show();

                            //creating the upload object to store uploaded image details
                            Upload upload = new Upload(editTextName.getText().toString().trim(), taskSnapshot.getDownloadUrl().toString());

                            //adding an upload to firebase database
                            String uploadId = mDatabase.push().getKey();
                            mDatabase.child(uploadId).setValue(upload);
                        }
                    })
                    .addOnFailureListener(new OnFailureListener() {
                        @Override
                        public void onFailure(@NonNull Exception exception) {
                            progressDialog.dismiss();
                            Toast.makeText(getApplicationContext(), exception.getMessage(), Toast.LENGTH_LONG).show();
                        }
                    })
                    .addOnProgressListener(new OnProgressListener<UploadTask.TaskSnapshot>() {
                        @Override
                        public void onProgress(UploadTask.TaskSnapshot taskSnapshot) {
                            //displaying the upload progress
                            double progress = (100.0 * taskSnapshot.getBytesTransferred()) / taskSnapshot.getTotalByteCount();
                            progressDialog.setMessage("Uploaded " + ((int) progress) + "%...");
                        }
                    });
        } else {
            //display an error if no file is selected
        }*/
    }
}
